---
title: "CviÄenÃ­ 6: Å˜etÄ›zce a regulÃ¡rnÃ­ vÃ½razy"
subtitle: "MPE_AVED - AnalÃ½za a vizualizace ekonomickÃ½ch dat"
author: "VaÅ¡e meno"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    theme: cosmo
    highlight: tango
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
# rm(list = ls())
```

# ğŸ“š Ãšvod

V tomto cviÄenÃ­ sa nauÄÃ­me pracovaÅ¥ s:

- **ReÅ¥azcami** (strings) v R
- **RegulÃ¡rnymi vÃ½razmi** (regex)
- **BalÃ­kom `stringr`** pre manipulÃ¡ciu s textom

# ğŸ“¦ NaÄÃ­tanie balÃ­kov

```{r packages}
# NaÄÃ­tajte potrebnÃ© balÃ­ky: tibble, readr, stringr
library(tibble)
library(readr)
library(stringr)

```

---

# ğŸ”¥ Na zahÅ™Ã¡tÃ­

## Ãškol 1: Generovanie nÃ¡zvov sÃºborov

**Zadanie:** Chcete sestavit jmÃ©na souborÅ¯, do kterÃ½ch budete uklÃ¡dat data. Soubory se majÃ­ jmenovat "data001.csv", "data002.csv" atd. Sestavte vektor `jmena` tÅ™iceti takovÃ½ch jmen.

**Funkcie:** `str_c()`, `str_pad()`

```{r ukol1_jmena}
# Vytvorte vektor 'jmena' s 30 nÃ¡zvami sÃºborov formÃ¡tu "data001.csv"
str_pad(1:30, width = 3, side = "left", pad = "0")
jmena <- str_c("data", str_pad(1:30, width = 3, side = "left", pad = "0"), ".csv")

# PrvÃ½ch 10 nÃ¡zvov
jmena |> head(10)

```
**PoznÃ¡mky:**

- `str_pad()` - doplnÃ­ ÄÃ­sla nulami na poÅ¾adovanÃº Å¡Ã­rku, vo vzore je parameter pad = 0 (bez uvodzoviek), lebo 0 automaticky konvertuje. ved aj cisla z vektora 1:30 automaticky konvertuje 
- `str_c()` - spojÃ­ reÅ¥azce dohromady

---

## Ãškol 2: DÄºÅ¾ka reÅ¥azcov

**Zadanie:** ZjistÄ›te

- kolik mÃ¡ vektor `jmena` prvkÅ¯
- kolik znakÅ¯ majÃ­ jednotlivÃ© prvky vektoru `jmena`

**Funkcie:** `length()`, `str_length()`

```{r ukol2_delka}
# PoÄet prvkov vektora 'jmena'
jmena |> length()

# PoÄet znakov v kaÅ¾dom prvku vektora 'jmena'
jmena |> str_length()

```

---

## Ãškol 3: PrÃ¡ca s dÃ¡tumami v reÅ¥azcoch

**Zadanie:** NaÄtÄ›te datovÃ½ soubor `exdata06.RData`. ProhlÃ©dnÄ›te si tabulku `measurement`.

Upravte tabulku:

1. Pridajte sloupce `year`, `month` a `day` - data extrahujte ze sloupce `time` (formÃ¡t: `yyyymmdd`)
2. ZruÅ¡te sloupec `time`
3. ZajistÄ›te poÅ™adÃ­ sloupcÅ¯: `year`, `month`, `day`, `class`, `measurement`
4. Ze sloupce `class` odstraÅˆte pÅ™ebyteÄnÃ© mezery

**Funkcie:** `str_sub()`, `str_trim()`, `as.integer()`

```{r ukol3_measurement}
# NaÄÃ­tajte dÃ¡ta
load("exdata06.RData")

# Pozrite si Å¡truktÃºru tabulky 'measurement'

# 1. Extrahujte rok (prvÃ© 4 znaky)

measurement$year <- str_sub(measurement$time, 1, 4)|> as.integer()

# 2. Extrahujte mesiac (znaky 5-6)
measurement$month <- str_sub(measurement$time,5, 6)|> as.integer()

# 3. Extrahujte deÅˆ (znaky 7-8)
measurement$day <- str_sub(measurement$time,7, 8)|> as.integer()

# Ina moznost extrahovania datumu
library(lubridate, quietly = TRUE)
measurement$time |> ymd() |> year() |> head(10)
measurement$time |> ymd() |> month() |> head(10)
measurement$time |> ymd() |> day() |> head(10)

# 4. OdstrÃ¡Åˆte medzery zo stÄºpca 'class'
measurement$class <- str_trim(measurement$class)

# 5. Preusporiadajte stÄºpce
measurement <- measurement[, c("year", "month", "day", "class", "measurement")]

# VypÃ­Å¡te vÃ½sledok
measurement

```

**PoznÃ¡mky:**

- `str_sub(text, start, end)` - vyextrahuje podreÅ¥azec
- `str_trim(text)` - odstrÃ¡ni medzery na zaÄiatku a konci
- AlternatÃ­vne: pouÅ¾ite funkcie z balÃ­ka `lubridate` (`ymd()`, `year()`, `month()`, `day()`)

---

# ğŸ“œ HrÃ¡tky s DeklaracÃ­ nezÃ¡vislosti

Text Deklarace nezÃ¡vislosti obsahuje chyby - miestami je viac medzier, neÅ¾ by malo byÅ¥.

## Ãškol 1: Detekcia a oprava medzier
Vektor Å™etÄ›zcÅ¯ 'deklarace' obsahuje text Deklarace nezÃ¡vislosti, jak jej pÅ™epsal neÅ¡ikovnÃ½ pÃ­saÅ™, kterÃ½ mÃ­sty napsal vÃ­c mezer, neÅ¾ se patÅ™Ã­.

**Zadanie:**

1. Vytvorte logickÃ½ vektor, kterÃ½ bude mÃ­t TRUE u tÄ›ch prvkÅ¯ vektoru `deklarace`, kterÃ© obsahujÃ­ nÄ›kolik mezer za sebou
2. SpoÄÃ­tejte poÄet takovÃ½ch chyb v kaÅ¾dÃ©m Å™etÄ›zci
3. Opravte text tak, aby byla vÅ¡ude vÅ¾dy prÃ¡vÄ› jedna mezera

**Funkcie:** `str_detect()`, `str_count()`, `str_replace_all()`, `str_squish()`

**Regex:** `\\s{2,}` - dva alebo viac whitespace znakov za sebou

```{r ukol1_deklarace}
# 1. LogickÃ½ vektor: kde sÃº duplicitnÃ© medzery?
# PouÅ¾ite regex \\s{2,}
str_detect(deklarace, "\\s{2,}") # parametre: string, pattern

# 2. PoÄet duplicitnÃ½ch medzier v kaÅ¾dom prvku
str_count(deklarace, "\\s{2,}")

# 3. OdstrÃ¡nenie duplicitnÃ½ch medzier
# SpÃ´sob 1: str_replace_all()
str_replace_all(deklarace, "\\s+", " ") # parametre: text, co nahradit, cim nahradit

# SpÃ´sob 2: str_squish() (jednoduchÅ¡ie)
str_squish(deklarace)

deklarace <- str_replace_all(deklarace, "\\s+", " ") # parametre: text, co nahradit, cim nahradit

```

**PoznÃ¡mky:**

- `\\s` - whitespace (medzera, tab, novÃ½ riadok)
- `{2,}` - 2 alebo viac opakovanÃ­
- `str_squish()` - odstrÃ¡ni duplicitnÃ© medzery a trim

---

## Ãškol 2: FormÃ¡tovanie textu

**Zadanie:** VypiÅ¡te druhÃ½ odstavec opravenÃ© `Deklarace` tak, aby se text pÄ›knÄ› zalomil do odstavce o Å¡Ã­Å™ce 60 znakÅ¯.

**Funkcie:** `str_wrap()`, `cat()`

```{r ukol2_wrap}
# VyformÃ¡tujte druhÃ½ odstavec na Å¡Ã­rku 60 znakov
deklarace[2] |> str_wrap(width = 60) |> cat()

```

**PoznÃ¡mky:**

- `str_wrap()` - zalomÃ­ text na danÃº Å¡Ã­rku
- `cat()` - vypÃ­Å¡e text s interpretÃ¡ciou Å¡peciÃ¡lnych znakov (`\n`)

---

## Ãškol 3: Pokazenie textu (dobrovoÄ¾nÃ½, Å¥aÅ¾kÃ½)

**Zadanie:** Rozmyslete si, jak je moÅ¾nÃ© pokazit text deklarace tak, Å¾e mÃ­sto jednÃ© mezery je v textu nÄ›kdy vÄ›tÅ¡Ã­ mnoÅ¾stvÃ­ mezer.

```{r ukol3_pokazeni, eval=FALSE}
# Tento Ãºkol je na doma - skÃºste vymyslieÅ¥ spÃ´sob, ako pokaziÅ¥ text
# NÃ¡poveda:
# 1. Spojte odstavce do jednÃ©ho reÅ¥azca (oddelenÃ© Å¡peciÃ¡lnym znakom)
# 2. RozdeÄ¾te text na Äasti v miestach, kde sÃº medzery
# 3. Zlepte Äasti spÃ¤Å¥ s nÃ¡hodnÃ½m poÄtom medzier
# 4. RozdeÄ¾te spÃ¤Å¥ na odstavce

dekl_col <- str_c(deklarace, collapse = "|")


```

---

# ğŸ”§ Oprava naÄtenÃ½ch dat

## Ãškol 1: NaÄÃ­tanie tabuÄ¾ky

**Zadanie:** NaÄtÄ›te tabulku ze souboru "tec00001.tsv.gz" a vypiÅ¡te jejÃ­ hlaviÄku.

**PoznÃ¡mky:** JednÃ¡ se o data z Eurostatu o HDP na obyvateÄ¾a.

```{r ukol1_tec}
# NaÄÃ­tajte TSV sÃºbor (tab-separated values)
# col_types = "cnnnnnnnnnnnn" (1 character + 12 numeric stÄºpcov)
tec00001tsv <- read_tsv("tec00001.tsv.gz",
                        col_types = "cnnnnnnnnnnnn")

# VypÃ­Å¡te hlaviÄku
head(tec00001tsv)

```

---

## Ãškol 2: Rozdelenie prvÃ©ho stÄºpca

**Zadanie:** Upravte tabulku `tec00001tsv` tak, Å¾e prvnÃ­ sloupec nahradÃ­te sloupci `item`, `unit` a `geo`, kterÃ© zÃ­skÃ¡te rozdÄ›lenÃ­m pÅ¯vodnÃ­ho prvnÃ­ho sloupce v mÃ­stech, kde je ÄÃ¡rka (`,`).

**Funkcie:** `str_split()`, `str_split_fixed()`, alebo `tidyr::separate_wider_delim()`

```{r ukol2_split}
# SpÃ´sob 1: str_split() a manuÃ¡lne priradenie
mat <- str_split(tec00001tsv$`na_item,unit,geo\\time`, ",", simplify = TRUE)
  # vezme stlpec, zoberie riadky a rozdeli ho podla ciarky

tec00001tsv_copy <- tec00001tsv
tec00001tsv_copy$item <- mat[,1]
tec00001tsv_copy$unit <- mat[,2]
tec00001tsv_copy$geo <- mat[,3]

col_no <- tec00001tsv_copy |> colnames() |> length()
# tec00001tsv_copy <- tec00001tsv_copy[, c(col_no-2 : col_no, 2 : col_no - 3)] # tu ma byt c(14:16, 2:13)!!!

tec00001tsv_copy |> head()

# TOTO bude pridane do rieseni.. vezmi nazov, oddelovac je ,
# DOKONC tec00001tsv$item <- str_split(tec00001tsv$item, )

# SpÃ´sob 2: str_split_fixed() a cbind()
mat <- str_split_fixed(tec00001tsv[[1]], ",", 3) # rozdeli na 3 stlpce
# DOKONC..

# SpÃ´sob 3: tidyr::separate_wider_delim() (najjednoduchÅ¡Ã­)
# DOKONC...

# VypÃ­Å¡te vÃ½sledok


```

**PoznÃ¡mky:**

- PrvÃ½ stÄºpec mÃ¡ nÃ¡zov `na_item,unit,geo\\time`
- MusÃ­ sa pouÅ¾iÅ¥ spÃ¤tnÃ© apostrofy: `` `nÃ¡zov` ``
- Alebo pouÅ¾ite `[[1]]` pre prÃ­stup podÄ¾a pozÃ­cie

---

# â›ï¸ DolovÃ¡nÃ­ dat z Å™etÄ›zcÅ¯

SÃºbor "shops.txt" obsahuje data o cenÃ¡ch a nÃ¡kladoch na dopravu ÃšÅ¾asnÃ½ch udÄ›lÃ¡tekâ„¢ v rÃ´znych obchodoch. DÃ¡ta bohuÅ¾iaÄ¾ nie sÃº v Å¾iadnom Å¡tandardnom formÃ¡te.

## Ãškol 1: NaÄÃ­tanie dÃ¡t

**Zadanie:** NaÄtÄ›te data (po Å™Ã¡dcÃ­ch) a vÃ½sledok uloÅ¾te do vektora `shopping`.

**Funkcie:** `read_lines()` - lebo je to txt

```{r ukol1_shops}
# NaÄÃ­tajte sÃºbor po riadkoch
shopping <- read_lines('shops.txt')

# VypÃ­Å¡te prvÃ½ch 6 riadkov pomocou cat()
shopping |> head(6) |> cat(sep = "\n")

```

---

## Ãškol 2: Vytvorenie tabuÄ¾ky

**Zadanie:** Vytvorte z dat tabulku `shops`, kterÃ¡ bude mÃ­t sloupce:

1. `shop` - kÃ³dovÃ© jmÃ©no obchodu
2. `price` - cena produktu (ÄÃ­slo)
3. `shipping` - nÃ¡klady na dopravu (ÄÃ­slo)
4. `total_price` - celkovÃ© nÃ¡klady

**Funkcie:** `str_extract()`, `str_match()`, `str_remove()`, `str_replace()`, `as.numeric()`

**Regex vzory:**

- NÃ¡zov obchodu: `^[-\\w]+`
- Cena: `cena:\\s*\\d+\\s*\\.?\\s*\\d*\\s*KÄ`
- Doprava: `doprava:\\s*\\d+\\s*KÄ`

```{r ukol2_shops_tabulka}
# Najprv nahraÄte "zdarma" za "0 KÄ"
shopping <- shopping |> str_replace("zdarma", "0 KÄ")
shopping |> head()

# Vytvorte tabulku s 4 stÄºpcami

# 1. Extrahujte nÃ¡zov obchodu (od zaÄiatku po prvÃº medzeru)
str_extract(shopping, "^[-\\w]+") |> head()

# 2. Extrahujte cenu (ÄÃ­slo z "cena: ... KÄ")
str_extract(shopping, "[-+]?[.]*")

# Vysvetlenie vyrazu vo vzore:
# cena:\\s*(\\d+\\s*\\.?\\s*\\d*)\\s*KÄ"
# 1. cena: - doslovnÃ½ text "cena:"
# 2. \\s* - nula nebo vÃ­ce bÃ­lÃ½ch znakÅ¯ (mezery, tabulÃ¡tory)
# 
# \\s = bÃ­lÃ½ znak (whitespace)
# * = nula nebo vÃ­ce opakovÃ¡nÃ­
# 
# 3. (\\d+\\s*\\.?\\s*\\d*) - zachytÃ¡vajÃ­cÃ­ skupina pro samotnou ÄÃ­selnou hodnotu:
# 
# \\d+ = jedna nebo vÃ­ce ÄÃ­slic (povinnÃ©)
# \\s* = nepovinnÃ© mezery
# \\.? = nepovinnÃ¡ teÄka (desetinnÃ½ oddÄ›lovaÄ) - ? znamenÃ¡ 0 nebo 1Ã—
# \\s* = nepovinnÃ© mezery
# \\d* = nula nebo vÃ­ce ÄÃ­slic (desetinnÃ¡ ÄÃ¡st - nepovinnÃ¡)
# 
# 4. \\s* - nepovinnÃ© mezery pÅ™ed mÄ›nou
# 5. KÄ - doslovnÃ½ text "KÄ"

# 3. Extrahujte dopravu (ÄÃ­slo z "doprava: ... KÄ")


# 4. VypoÄÃ­tajte celkovÃº cenu


# VypÃ­Å¡te vÃ½sledok

### !!! pozri riesenie 4, vysvetlovanie od riesenia od 4 po 1, riesenie 1 je pre zaciatocnikov
### shipping = str_extract(shopping, "doprava:.*?KÄ") |>  # ten ? sposobi, ze to bude "LAZY" nie hladne.. to riesenie nie je uplne bezpecne, ale pre tento pripad to funguje
#### aj pri cene je LAZY price = str_extract(shopping, "cena:.*?KÄ") |> 
# to riesenie 3 je paranoidnejsie riesenie, tie vyrazy zozeru len to, co potrebujem a nic viac

# price = str_extract(shopping, "cena:\\s*\\d+\\s*\\.?\\s*\\d*\\s*KÄ") |> 
#         str_remove_all("[\\s,\\.]") |> 
#         str_extract("\\d+") |>  # 
#         as.numeric(),


# shops <- tibble(
#    shop = str_extract(shopping, "^[-\\w]+"),
    #price = str_match(shopping, "cena:\\s*(\\d+\\s*\\.?\\s*\\d*)\\s*KÄ")[, 2], # ta 2 je referencia ako "pamat" pre regularny vyraz. Je to odkaz na tu zatvorku v regularnom vyraze, lebo je vlastne druha v poradi
#    shipping = str_match(shopping, "doprava:\\s*(\\d+)\\s*KÄ")[, 2]

```

**NÃ¡poveda:**

- PostupnosÅ¥: extrahujte text â†’ odstrÃ¡Åˆte neÅ¾iaduce Äasti â†’ konvertujte na ÄÃ­slo
- PouÅ¾ite pipe operÃ¡tor `|>` pre postupnÃ© operÃ¡cie
- `str_match()[, 2]` vrÃ¡ti prvÃº zachytenÃº skupinu z regex

---

## Ãškol 3: NajlacnejÅ¡Ã­ obchod

**Zadanie:** KtorÃ½ obchod je najlacnejÅ¡Ã­ (najniÅ¾Å¡ia celkovÃ¡ cena)?

```{r ukol3_najlacnejsi}
# NÃ¡jdite obchod s minimÃ¡lnou celkovou cenou


```

---

# ğŸƒ Trick or Treat, Trump or Tramp

V tejto sekcii budeme pracovaÅ¥ s textom a vyhÄ¾adÃ¡vaÅ¥ vzory.

## Ãškol 1: Detekcia vzoru

**Zadanie:** NapÃ­Å¡te regex na detekciu slov obsahujÃºcich "trump" alebo "tramp".

```{r trump1}
text <- c("Trump", "tramp", "trumpet", "Donald Trump", "trampoline", "stumped")

# Detekujte slovÃ¡ obsahujÃºce "trump" alebo "tramp" (case-insensitive)


```

---

## Ãškol 2: Extrakcia

**Zadanie:** Extrahujte vÅ¡etky vÃ½skyty slov zaÄÃ­najÃºcich na "tru" alebo "tra".

```{r trump2}
# Extrahujte slovÃ¡ zaÄÃ­najÃºce na "tru" alebo "tra"


```

---

## Ãškol 3: NÃ¡hrada

**Zadanie:** NahraÄte vÅ¡etky vÃ½skyty "trump" za "TRUMP" (case-insensitive).

```{r trump3}
# NahraÄte "trump" za "TRUMP" (ignorujte veÄ¾kosÅ¥ pÃ­smen)


```

---

## Ãškol 4: PoÄÃ­tanie

**Zadanie:** SpoÄÃ­tajte poÄet vÃ½skytov slov obsahujÃºcich "tr".

```{r trump4}
# SpoÄÃ­tajte slovÃ¡ obsahujÃºce "tr"


```

---

## Ãškol 5: Rozdelenie

**Zadanie:** RozdeÄ¾te text na slovÃ¡.

```{r trump5}
sentence <- "The quick brown fox jumps over the lazy dog"

# RozdeÄ¾te vetu na slovÃ¡


```

---

## Ãškol 6: ValidÃ¡cia emailu

**Zadanie:** Vytvorte regex na kontrolu, Äi je reÅ¥azec validnÃ¡ e-mailovÃ¡ adresa.

```{r trump6}
emails <- c("user@example.com", "invalid-email", "test@test.co.uk", "@wrong.com")

# Validujte e-mailovÃ© adresy
# JednoduchÃ½ regex: \\w+@\\w+\\.\\w+


```

---

## Ãškol 7: Extrakcia dÃ¡tumu

**Zadanie:** Extrahujte dÃ¡tum vo formÃ¡te DD/MM/YYYY z textu.

```{r trump7}
text <- "Narodil som sa 15/03/1990 a dnes je 28/10/2025."

# Extrahujte dÃ¡tumy vo formÃ¡te DD/MM/YYYY
# Regex: \\d{2}/\\d{2}/\\d{4}


```

---

# ğŸ“ UÅ¾itoÄnÃ© regex vzory

PoznÃ¡mky pre prÃ¡cu s regulÃ¡rnymi vÃ½razmi:

## ZÃ¡kladnÃ© metaznaky

| Vzor | VÃ½znam |
|------|--------|
| `.` | Ä½ubovoÄ¾nÃ½ znak |
| `^` | ZaÄiatok reÅ¥azca |
| `$` | Koniec reÅ¥azca |
| `\\d` | ÄŒÃ­slica (0-9) |
| `\\w` | AlfanumerickÃ½ znak (a-z, A-Z, 0-9, _) |
| `\\s` | Whitespace (medzera, tab, novÃ½ riadok) |

## KvantifikÃ¡tory

| Vzor | VÃ½znam |
|------|--------|
| `*` | 0 alebo viac |
| `+` | 1 alebo viac |
| `?` | 0 alebo 1 |
| `{n}` | Presne n krÃ¡t |
| `{n,}` | n alebo viac krÃ¡t |
| `{n,m}` | Medzi n a m krÃ¡t |

## Skupiny a alternatÃ­vy

| Vzor | VÃ½znam |
|------|--------|
| `(...)` | ZachytÃ¡vajÃºca skupina |
| `(?:...)` | NezachytÃ¡vajÃºca skupina |
| `|` | AlternatÃ­va (OR) |
| `[abc]` | Jeden znak z mnoÅ¾iny |
| `[^abc]` | Jeden znak MIMO mnoÅ¾iny |

---

# ğŸ¯ Zhrnutie funkciÃ­ stringr

## Detekcia a vyhÄ¾adÃ¡vanie

```r
str_detect(string, pattern)    # TRUE/FALSE
str_which(string, pattern)     # Indexy
str_count(string, pattern)     # PoÄet vÃ½skytov
str_locate(string, pattern)    # PozÃ­cia prvÃ©ho vÃ½skytu
str_locate_all(string, pattern) # PozÃ­cie vÅ¡etkÃ½ch vÃ½skytov
```

## Extrakcia

```r
str_extract(string, pattern)      # PrvÃ½ vÃ½skyt
str_extract_all(string, pattern)  # VÅ¡etky vÃ½skyty
str_match(string, pattern)        # S capturing groups
str_sub(string, start, end)       # PodreÅ¥azec podÄ¾a pozÃ­cie
```

## ManipulÃ¡cia

```r
str_replace(string, pattern, replacement)     # PrvÃ½ vÃ½skyt
str_replace_all(string, pattern, replacement) # VÅ¡etky vÃ½skyty
str_remove(string, pattern)                   # = str_replace(x, "", "")
str_remove_all(string, pattern)
str_to_lower(string)           # Na malÃ© pÃ­smenÃ¡
str_to_upper(string)           # Na veÄ¾kÃ© pÃ­smenÃ¡
str_to_title(string)           # Title Case
str_trim(string)               # OdstrÃ¡ni medzery na okrajoch
str_squish(string)             # OdstrÃ¡ni duplicitnÃ© medzery
```

## Spojovanie a rozdeÄ¾ovanie

```r
str_c(..., sep = "")           # Spojenie reÅ¥azcov
str_flatten(string, collapse = "") # Zredukovanie vektora na 1 reÅ¥azec
str_split(string, pattern)     # Rozdelenie (vracia list)
str_split_fixed(string, pattern, n) # Rozdelenie (vracia maticu)
```

## DÄºÅ¾ka a formÃ¡tovanie

```r
str_length(string)             # PoÄet znakov
str_pad(string, width, pad = " ") # Doplnenie na Å¡Ã­rku
str_trunc(string, width)       # SkrÃ¡tenie
str_wrap(string, width)        # Zalomenie textu
```

---

# ğŸ”— UÅ¾itoÄnÃ© odkazy

- [stringr cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)
- [regex101.com](https://regex101.com/) - testovanie regex online
- [R for Data Science - Strings](https://r4ds.had.co.nz/strings.html)

